<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>Babylon - Basic scene</title>
  <style>
    html,
    body {
      overflow: hidden;
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
    }

    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none;
    }
  </style>
  <script src="js/babylon.js"></script>
  <script src="js/hand.js"></script>
  <script src="js/cannon.js"></script>
  <!-- optional physics engine -->
</head>

<body>

  <canvas id="renderCanvas"></canvas>
  <script type="text/javascript">
    // Get the canvas element from our HTML below
    var canvas = document.querySelector("#renderCanvas");
    // Load the BABYLON 3D engine
    var engine = new BABYLON.Engine(canvas, true);
    // -------------------------------------------------------------
    // Here begins a function that we will 'call' just after it's built
    var createScene = function() {
      // Now create a basic Babylon Scene object
      var scene = new BABYLON.Scene(engine);

      // This creates and positions a free camera
      var camera = new BABYLON.ArcRotateCamera("Camera", 0, 0.8, 1, BABYLON.Vector3.Zero(), scene);
      camera.lowerBetaLimit = 0.1;
      camera.upperBetaLimit = (Math.PI / 2) * 0.9;
      camera.lowerRadiusLimit = 50;
      camera.upperRadiusLimit = 300;
      camera.attachControl(canvas, true);

      // This creates a light, aiming 0,1,0 - to the sky.
      var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
      light.diffuse = new BABYLON.Color3(1, 1, 1);
      light.specular = new BABYLON.Color3(1,1,1);

      // var direction light


      // Dim the light a small amount
      light.intensity = 0.9;

      // ground material
      var groundMaterial = new BABYLON.StandardMaterial("ground", scene);
      groundMaterial.diffuseTexture = new BABYLON.Texture("images/grass.jpg", scene);

      // wireframe material
      var wire = new BABYLON.StandardMaterial("wires", scene);
      wire.wireframe = true;

      // silk material
      var silk = new BABYLON.StandardMaterial("silk1", scene);
      silk.diffuseTexture =  new BABYLON.Texture("images/silk.jpg", scene);

      // laser material
      var laser = new BABYLON.StandardMaterial("laser", scene);
      laser.diffuseTexture =  new BABYLON.Texture("images/smoke.jpg", scene);


      // ground mesh
      var groundPlane = BABYLON.Mesh.CreateGround("ground1", 1000, 1000, 2, scene);
      groundPlane.material = groundMaterial;
      // rotate plane
      groundPlane.position = new BABYLON.Vector3(3, 3, 3);

      // add box - square
      var theBox = BABYLON.Mesh.CreateBox("theBox", 20.0, scene, false, BABYLON.Mesh.DEFAULTSIDE);
      theBox.position = new BABYLON.Vector3(3, 10, 3);
      theBox.material = silk;

      // adding polygon - torus
      var poly = BABYLON.Mesh.CreateTorus("torus", 14, 50, 10, scene, false, BABYLON.Mesh.DEFAULTSIDE);
      poly.position = new BABYLON.Vector3(55, 40, 3);
      poly.material = groundMaterial;

      // adding knot
      var theKnot = BABYLON.Mesh.CreateTorusKnot("knot", 15, 15, 100, 55, 2, 3, scene, false, BABYLON.Mesh.DEFAULTSIDE);
      theKnot.position = new BABYLON.Vector3(-50, 30, 8);
      theKnot.material = wire;

      // animation
  //    var animationBox = new BABYLON.Animation("myAnimation", "position.y", 100, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
  //    scene.beginAnimation(poly, 0, 100, true);

      // shorthand Animation
    //  BABYLON.Animation.CreateAndStartAnimation('boxScale', theBox, 'scaling.y', 30, 120, 1.0, 8.5);
    //  BABYLON.Animation.CreateAndStartAnimation('boxScale', theBox, 'scaling.x', 30, 120, 1.0, 8.5);

    // Creating an easing function
//var easingFunction = new BABYLON.QuadraticEase();

// For each easing function, you can choose beetween EASEIN (default), EASEOUT, EASEINOUT
//easingFunction.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);

// Adding the easing function to the animation
// animationBox.setEasingFunction(easingFunction);

      // Animation keys
    var keys = [];
    //At the animation key 0, the value of scaling is "1"
    keys.push({
        frame: 0,
        value: 15
    });

    //At the animation key 20, the value of scaling is "0.2"
    keys.push({
        frame: 20,
        value: 30
    });

    //At the animation key 100, the value of scaling is "1"
    keys.push({
        frame: 100,
        value: 40
    });

    //Adding keys to the animation object
    //    animationBox.setKeys(keys);

        //Then add the animation object to box1
  //      theKnot.animations.push(animationBox);

        //Finally, launch animations on box1, from key 0 to key 100 with loop activated
  //      scene.beginAnimation(theKnot, 0, 100, true);


  //When pointer down event is raised
    // scene.onPointerDown = function (evt, pickResult) {

scene.actionManager = new BABYLON.ActionManager(scene);

var actualY = theKnot.position.y;

//When pointer down event is raised
    scene.onPointerDown = function (evt, pickResult) {
        // if the click hits the ground object, we change the impact position
        if (pickResult.hit) {
            theKnot.position.x = pickResult.pickedPoint.x;
            theKnot.position.y = pickResult.pickedPoint.y;
            theKnot.position.z = pickResult.pickedPoint.z;
            
        }
    };



// keyboard shortcuts tests
scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, function (evt) {
   if (evt.sourceEvent.key == "u") {
         theKnot.position.y += 5;
   }
    if (evt.sourceEvent.key == "d") {
      theKnot.position.y -= 5;
    }
    if (evt.sourceEvent.key == "b") {
      theKnot.position.z += 5;
    }
    if (evt.sourceEvent.key == "f") {
      theKnot.position.z -= 5;
    }
    if (evt.sourceEvent.key == "r") {
      theKnot.position.x += 5;
    }
    if (evt.sourceEvent.key == "l") {
      theKnot.position.x -= 5;
    }
}));

      // add cylinder
      var cylinder = BABYLON.Mesh.CreateCylinder("cylinder", 40, 20, 15, 6, 1, scene);
      cylinder.material = laser;
      cylinder.position = new BABYLON.Vector3(10, 13, 30);

      // Skybox --- sky images
      var skybox = BABYLON.Mesh.CreateBox("skyBox", 800.0, scene);
      var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
      skyboxMaterial.backFaceCulling = false;
      skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("textures/skybox", scene);
      skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
      skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
      skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
      skyboxMaterial.disableLighting = true;
      skybox.material = skyboxMaterial;



      // ------morphing test --------------------------------------

      // material of morphing element
    //  var mat = new BABYLON.StandardMaterial("mat1", scene);
    //  mat.alpha = 1.0;
  //    mat.diffuseColor = groundMaterial
    //  mat.backFaceCulling = false;
    //  mat.wireframe = false;


      // path function
      var pathFunction = function(k) {
        var path = [];
        for (var i = 0; i < 200; i++) {
          var x = i - 100;
          var y = 0;
          var z = k;
          // gets the positions of the element
          path.push(new BABYLON.Vector3(x, y, z));
        }
        return path;
      };


      // update path function
      var updatePath = function(path, k) {
        for (var i = 0; i < path.length; i++) {
          var x = path[i].x;
          var z = path[i].z;
          var y = 20 * Math.sin(i / 10) * Math.sin(k + z / 40);
          path[i].x = x;
          path[i].y = y;
          path[i].z = z;
        }
      };



      // ribbon creation
      var sideO = BABYLON.Mesh.BACKSIDE;
      var pathArray = [];
      for (var i = -200; i < 200; i++) {
        pathArray.push(pathFunction(i * 2));
      }
    //  var mesh = BABYLON.Mesh.CreateRibbon("ribbon", pathArray, false, false, 0, scene, true, sideO);
    //  mesh.material = mat;
    //  mesh.position = new BABYLON.Vector3(3.2, 3.2, 3.2);



      // morphing
      /*var k = 0;
      scene.registerBeforeRender(function() {
        // update pathArray
        for (var p = 0; p < pathArray.length; p++) {
          updatePath(pathArray[p], k);
        }
        // ribbon update
        mesh = BABYLON.Mesh.CreateRibbon(null, pathArray, null, null, null, null, null, null, mesh);
        k += 0.05 ;
        //	pl.position = camera.position;
      });*/



      //When user clicks the ground
      //    scene.onPointerDown = function (evt, pickResult) {
      // if the click hits the ground object, we change the impact position
      //    if (pickResult.hit) {
      //        hand.position.x = pickResult.pickedPoint.x;
      //        hand.position.y = pickResult.pickedPoint.y;
      //      }
      //  };

      // Leave this function
      return scene;
    }; // End of createScene function
    // -------------------------------------------------------------


    // Now, call the createScene function that you just finished creating
    var scene = createScene();
    // Register a render loop to repeatedly render the scene
    engine.runRenderLoop(function() {
      scene.render();
    });
    // Watch for browser/canvas resize events
    window.addEventListener("resize", function() {
      engine.resize();
    });
  </script>
</body>

</html>
